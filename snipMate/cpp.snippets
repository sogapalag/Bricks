##
## Preprocessor
# #include <...>
snippet std
	#include <bits/stdc++.h>

	using namespace std;
snippet tree
	#include <bits/stdc++.h>
	#include <ext/pb_ds/tree_policy.hpp>
	#include <ext/pb_ds/assoc_container.hpp>
	
	using namespace std;
	using namespace __gnu_pbds;

	template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;
##
## STL Collections/ type
#
snippet const
	const ${1:int} ${2:N} = ${3:100005}; 
snippet inf
	const int INF = 0x3f3f3f3f;
snippet lnf
	const long long INF = 0x3f3f3f3f3f3f3f3f;
snippet ll
	long long ${1};
snippet ld
	long double ${1};
snippet pi
	pair<int, int> ${1};
snippet pl
	pair<long long, long long> ${1};
snippet pd
	pair<double, double> ${1};
snippet vi
	vector<int> ${1};
snippet vl
	vector<long long> ${1};
snippet vpi
	vector<pair<int, int>> ${1};
snippet map
	map<${1:Key}, ${2:T}> ${3};
snippet mset
	multiset<${1:T}> ${2};
snippet mmap
	multimap<${1:Key}, ${2:T}> ${3};
snippet uset
	unordered_set<${1:T}> ${2};
snippet umap
	unordered_map<${1:Key}, ${2:T}> ${3};
snippet umset
	unordered_multiset<${1:T}> ${2};
snippet ummap
	unordered_multimap<${1:Key}, ${2:T}> ${3};
snippet stack
	stack<${1:T}> ${2};
snippet queue
	queue<${1:T}> ${2};
snippet pqueue
	priority_queue<${1:T}> ${2};
# I/O
snippet ci
	cin >> ${1};
snippet co
	cout << ${1};
snippet cl
	cout << ${1} << "\n";
snippet debug
	#define dbg(x) cerr<<#x<<" = "<<(x)<<endl;
## Iteration
#
snippet ifi
	if (${1}) ${0};
snippet if 
	if (${1}) {
		${0:${VISUAL}}
	}
snippet el
	else {
		${0:${VISUAL}}
	}
snippet elif
	else if (${1}) {
		${0:${VISUAL}}
	}
snippet t
	${1} ? ${2} : ${3};
snippet f
	for (int ${1:i} = ${2:0}; $1 < ${3:n}; $1++) {
		${0:${VISUAL}}
	}
snippet f=
	for (int ${1:i} = ${2:1}; $1 <= ${3:n}; $1++) {
		${0:${VISUAL}}
	}
snippet fd
	for (int ${1:i} = ${2:n-1}; $1 >= ${3:0}; $1--) {
		${0:${VISUAL}}
	}
snippet fd=
	for (int ${1:i} = ${2:n}; $1 >= ${3:1}; $1--) {
		${0:${VISUAL}}
	}
snippet fa
	for (auto& ${1:p}: ${2:v}) {
		${0:${VISUAL}}
	}
snippet fit
	for (auto ${1:it} = ${2:v}.begin(); $1 != $2.end(); $1++) {
		${0:${VISUAL}}
	}
snippet fitd
	for (auto ${1:rit} = ${2:v}.rbegin(); $1 != $2.rend(); $1++) {
		${0:${VISUAL}}
	}
snippet wh
	while (${1:true}) {
		${0:${VISUAL}}
	}
## * quick func
#
snippet st
	struct ${1:Node} {
		${0:${VISUAL}}
	};
snippet au
	auto ${1:func} = [${2}](${3}){${0:${VISUAL}}};
snippet lbd
	[${1}](${2}){${0:${VISUAL}}}
snippet ms
	memset(${1:a}, ${2:0}, sizeof $1);
snippet mp
	make_pair(${1}, ${2});
snippet pb
	push_back(${1});
snippet eb
	emplace_back(${1});
snippet all
	${1:v}.begin(), $1.end()
snippet lb
	lower_bound(${1:a}, $1+${2:n}, ${3:val});
snippet lbv
	lower_bound(${1:v}.begin(), $1.end(), ${2:val});
snippet ub
	upper_bound(${1:a}, $1+${2:n}, ${3:val});
snippet ubv
	upper_bound(${1:v}.begin(), $1.end(), ${2:val});
snippet posl
	int ${1:i} = lower_bound(${2:a}, $2+${3:n}, ${4:val}) - $2;
snippet posu
	int ${1:i} = upper_bound(${2:a}, $2+${3:n}, ${4:val}) - $2;
snippet poslv
	int ${1:i} = lower_bound(${2:a}.begin(), $2.end(), ${3:val}) - $2.begin();
snippet posuv
	int ${1:i} = upper_bound(${2:a}.begin(), $2.end(), ${3:val}) - $2.begin();
snippet dedup
	sort(${1:v}.begin(), $1.end());
	$1.erase(unique($1.begin(), $1.end()), $1.end());
## template
#
snippet template_basic
	#include <bits/stdc++.h>

	using namespace std;


	void solve() {

	}

	int main() {
	    ios_base::sync_with_stdio(false);
	    cin.tie(NULL);
	    solve();
	    cout << endl;
	}
snippet template_ks
	#include <bits/stdc++.h>

	using namespace std;


	void solve() {

	}

	int main() {
	    ios_base::sync_with_stdio(false);
	    cin.tie(NULL);
	    int T; cin >> T;
	    for (int t = 1; t <= T; t++) {
	        cout << "Case #" << t << ": ";
	        solve();
	        cout << "\n";
	    }
	    fflush(stdout);
	}
## lib
#
snippet dsu
	struct Dsu {
	    int n;
	    vector<int> p;
	    
	    Dsu(int _n) { n = _n; p.resize(n); init(); }
	    inline void init() {
	        for (int i = 0; i < n; i++) {
	            p[i] = i;
	        }
	    }
	    inline int find(int x) {
	        return p[x] == x ? x: p[x] = find(p[x]);
	    }
	    inline bool join(int x, int y) {
	        x = find(x); y = find(y);
	        if (x == y) return false;
	        p[y] = x; return true;
	    }
	    inline bool check(int x, int y) {
	        return find(x) == find(y);
		}
	};
snippet fenwick
	template <typename T=int>
	struct Fenwick {
	    int n;
	    vector<T> v;
	    
	    Fenwick(int size = 100005) : n(size+1), v(n, 0) {}
	    inline void add(int p, T val) {
	        for (; p <= n; p += (p&-p)) { v[p] += val; }
	    }
	    inline T query(int p) {
	        T tmp = 0;
	        for (; p > 0; p -= (p&-p)) { tmp += v[p]; }
	        return tmp;
	    }
	    inline T query(int l, int r) {
	        return query(r) - query(l-1);
	    }
	};
snippet segtree
	template <typename T=int>
	struct Segtree {
	    int n; // leaf [n, 2n), view as original [0, n)
	    int sz_v;
	    const T ID;
	    vector<T> v; //tree
	    
	    Segtree(int _n = 100005) : n(_n), sz_v(n<<1) {
	        ID = T(); // set id
	        v.resize(sz_v);
	        init(); build();
	    }
	    void init() {// set leaf value
	        for (int i = 0; i < n; i++) {
	            // v[i+n] = raw[i];
	        }
	    }
	    void build() {
	        for (int i = n-1; i >= 0; i--) {
	            v[i] = v[i<<1] + v[i<<1|1];
	        }
	    }
	    inline void update(int p, T val) {
	        assert(p>=0);
	        for (v[p += n] = val; p > 1; p >>= 1) {
	            v[p>>1] = v[p] + v[p^1];
	        }
	    }
	    inline T query(int l, int r) {
	        T resl(ID), resr(ID);
	        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
	            if (l & 1) { resl = v[l++] + resl; }
	            if (r & 1) { resr = resr + v[--r]; }
	        }
	        return resl + resr;
	    }
	    // Note only when range-assign, single-access not interfere. e.g max
	    //inline void update(int l, int r, T val) {
	    //    for (l += n, r += n; l < r; l >>= 1, r >>= 1){
	    //        if (l & 1) { v[l++] = val; }
	    //        if (r & 1) { v[--r] = val; }
	    //    }
	    //}
	    //inline T query(int p){
	    //    T res(ID);
	    //    for (p += n; p > 0; p >>= 1) { res += v[p]; }
	    //    return res;
	    //}
	};
	
	struct Node {// monoid
	    int x;
	    Node(int _=0) : x(-0x3f3f3f3f) {} // write your own identity
	    Node(const Node& _r) : x(_r.x) {}// write your own
	    Node& operator = (const Node& _r) {
	        x = _r.x; // write your own
	        return *this;
	    }
	    Node& operator += (const Node& _r) {
	        x = max(x, _r.x); // write your own  !! may not communitative
	        return *this;
	    }
	    friend Node operator + (const Node& _lhs, const Node& _rhs) {
	        return Node(_lhs) += _rhs; // derive from +=
	    }
	};
	
	typedef Segtree<Node> Seg;
snippet modular
	namespace math {
	    const int MOD = 1000000007; // 998244353
	    
	    template <typename T>
	    struct modular {
	        constexpr modular() : val(0){}
	        constexpr modular(const modular<T>& _m) : val(_m.val) {}
	        template <typename U>
	        constexpr modular(const U& _r = U()) {
	            val = -MOD <= _r && _r < MOD ? _r: _r % MOD;
	            if (val < 0) { val += MOD; }
	        }
	        const T operator()() { return val; }
	        template <typename U>
	        explicit operator U() const { return static_cast<U>(val); }
	        
	        // arithmetic
	        modular<T>& operator+=(const modular<T>&);
	        template <typename U>
	        modular<T>& operator+=(const U&);
	        modular<T>& operator-=(const modular<T>&);
	        template <typename U>
	        modular<T>& operator-=(const U&);
	        modular<T>& operator*=(const modular<T>&);
	        template <typename U>
	        modular<T>& operator*=(const U&);
	        modular<T>& operator/=(const modular<T>&);
	        template <typename U>
	        modular<T>& operator/=(const U&);
	        
	        modular<T>& operator=(const modular<T>& _m) { val = _m.val; return *this; }
	        template <typename U>
	        modular<T>& operator=(const U& _r) { val = modular<T>(_r).val; return *this; }
	        modular<T> operator-() { return modular<T>(-val); }
	        
	        template <typename U>
	        friend bool operator==(const modular<U>&, const modular<U>&);
	        // I/O
	        friend std::istream& operator>>(std::istream& os, modular<T>& _m) {
	            os >> _m.val; _m *= 1;
	            return os;
	        }
	        friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) {
	            return os << _m.val;
	        }
	
	        template <typename U>
	        modular<T> exp(U e) {
	            modular<T> res = 1;
	            modular<T> b = val;
	            if (e < 0) { b = 1/b; e *= -1; }
	            for (; e; e >>= 1) {
	                if (e & 1) { res *= b; }
	                b *= b;
	            }
	            return res;
	        }
	    private:
	        T val;
	    };
	    // AddAssign
	    template <typename T>
	    modular<T>&
	    modular<T>::operator+=(const modular<T>& _m) {
	        if ((val += _m.val) >= MOD) { val -= MOD; }
	        return *this;
	    }
	    template <typename T>
	    template <typename U>
	    modular<T>& 
	    modular<T>::operator+=(const U& _r) { return *this += modular<T>(_r); }
	    // SubAssign
	    template <typename T>
	    modular<T>& 
	    modular<T>::operator-=(const modular<T>& _m) {
	        if ((val -= _m.val) < 0) { val += MOD; }
	        return *this;
	    }
	    template <typename T>
	    template <typename U>
	    modular<T>& 
	    modular<T>::operator-=(const U& _r) { return *this -= modular<T>(_r); }
	    // MultAssign
	    template <typename T>
	    modular<T>& 
	    modular<T>::operator*=(const modular<T>& _m) {
	        val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val;
	        return *this;
	    }
	    template <typename T>
	    template <typename U>
	    modular<T>& 
	    modular<T>::operator*=(const U& _r) { return *this *= modular<T>(_r); }
	    // DivAssign
	    template <typename T>
	    modular<T>& 
	    modular<T>::operator/=(const modular<T>& _m) {
	        T a = _m.val, b = MOD, u = 0, v = 1;
	        while (a != 0) {
	            T q = b / a;
	            b -= q * a; swap(a, b);
	            u -= q * v; swap(u, v); 
	        }
	        return *this *= u;
	    }
	    template <typename T>
	    template <typename U>
	    modular<T>& 
	    modular<T>::operator/=(const U& _r) { return *this /= modular<T>(_r); }
	    // Add
	    template <typename T>
	    inline modular<T>
	    operator+(const modular<T>& _lhs, const modular<T>& _rhs) {
	        return modular<T>(_lhs) += _rhs;
	    }
	    template <typename T, typename U>
	    inline modular<T>
	    operator+(const modular<T>& _lhs, const U& _rhs) {
	        return modular<T>(_lhs) += _rhs;
	    }
	    template <typename T, typename U>
	    inline modular<T>
	    operator+(const U& _lhs, const modular<T>& _rhs) {
	        return modular<T>(_lhs) += _rhs;
	    }
	    // Sub
	    template <typename T>
	    inline modular<T>
	    operator-(const modular<T>& _lhs, const modular<T>& _rhs) {
	        return modular<T>(_lhs) -= _rhs;
	    }
	    template <typename T, typename U>
	    inline modular<T>
	    operator-(const modular<T>& _lhs, const U& _rhs) {
	        return modular<T>(_lhs) -= _rhs;
	    }
	    template <typename T, typename U>
	    inline modular<T>
	    operator-(const U& _lhs, const modular<T>& _rhs) {
	        return modular<T>(_lhs) -= _rhs;
	    }
	    // Mult
	    template <typename T>
	    inline modular<T>
	    operator*(const modular<T>& _lhs, const modular<T>& _rhs) {
	        return modular<T>(_lhs) *= _rhs;
	    }
	    template <typename T, typename U>
	    inline modular<T>
	    operator*(const modular<T>& _lhs, const U& _rhs) {
	        return modular<T>(_lhs) *= _rhs;
	    }
	    template <typename T, typename U>
	    inline modular<T>
	    operator*(const U& _lhs, const modular<T>& _rhs) {
	        return modular<T>(_lhs) *= _rhs;
	    }
	    // Div
	    template <typename T>
	    inline modular<T>
	    operator/(const modular<T>& _lhs, const modular<T>& _rhs) {
	        return modular<T>(_lhs) /= _rhs;
	    }
	    template <typename T, typename U>
	    inline modular<T>
	    operator/(const modular<T>& _lhs, const U& _rhs) {
	        return modular<T>(_lhs) /= _rhs;
	    }
	    template <typename T, typename U>
	    inline modular<T>
	    operator/(const U& _lhs, const modular<T>& _rhs) {
	        return modular<T>(_lhs) /= _rhs;
	    }
	    // eq
	    template <typename T>
	    inline bool
	    operator==(const modular<T>& _lhs, const modular<T>& _rhs) {
	        return _lhs.val == _rhs.val;
	    }
	    template <typename T, typename U>
	    inline bool
	    operator==(const modular<T>& _lhs, const U& _rhs) {
	        return _lhs == modular<T>(_rhs);
	    }
	    template <typename T, typename U>
	    inline bool
	    operator==(const U& _lhs, const modular<T>& _rhs) {
	        return modular<T>(_lhs) == _rhs;
	    }
	    // neq
	    template <typename T>
	    inline bool
	    operator!=(const modular<T>& _lhs, const modular<T>& _rhs) {
	        return !(_lhs == _rhs);
	    }
	    template <typename T, typename U>
	    inline bool
	    operator!=(const modular<T>& _lhs, const U& _rhs) {
	        return !(_lhs == _rhs);
	    }
	    template <typename T, typename U>
	    inline bool
	    operator!=(const U& _lhs, const modular<T>& _rhs) {
	        return !(_lhs == _rhs);
	    }
	}
	using namespace math;
	typedef modular<int> mint;
snippet matrix
	namespace math {
	    // A = A X B, 0-based, n:dim
	    const int COL = 101;
	    void mat_mult(int n, mint A[][COL], mint B[][COL]){
	        mint res[n][n];
	        for (int i = 0; i < n; i++) {
	            for (int j = 0; j < n; j++) {
	                res[i][j] = 0;
	                for (int k = 0; k < n; k++) {
	                    res[i][j] += A[i][k] * B[k][j];
	                }
	            }
	        }
	        for (int i = 0; i < n; i++)
	            for (int j = 0; j < n; j++)
	                A[i][j] = res[i][j];
	    }
	    
	    // A = A^exp, n:dim
	    void mat_pow(int n, mint A[][COL], long long exp){
	        mint res[n][COL];
	        memset(res, 0, sizeof res);
	        for (int i = 0; i < n; i++)
	            res[i][i] = 1;
	        for(; exp; exp >>= 1){
	            if (exp & 1)
	                mat_mult(n, res, A);
	            mat_mult(n, A, A);
	        }
	        for (int i = 0; i < n; i++)
	            for (int j = 0; j < n; j++)
	                A[i][j] = res[i][j];
	    }
	}

